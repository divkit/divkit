package divkit.dsl.expression.generator.function

import divkit.dsl.expression.generator.util.resolveKotlinArgumentType
import divkit.dsl.expression.generator.util.resolveKotlinBasicType
import divkit.dsl.expression.generator.util.resolveKotlinType
import org.jetbrains.annotations.TestOnly
import java.io.File
import java.io.FileWriter
import java.io.Writer

class FunctionCodegen {

    fun generateCode(
        signatures: List<FunctionSignature>,
        packageName: String,
        outputDir: File,
        outputFilename: String = "Functions.kt",
    ) {
        FileWriter(File(outputDir, outputFilename)).use { fileWriter ->
            generateCode(fileWriter, packageName, signatures)
        }
    }

    @TestOnly
    fun generateCode(
        fileWriter: Writer,
        packageName: String,
        signatures: List<FunctionSignature>,
    ) {
        writeKtHeader(fileWriter, packageName)

        signatures.forEach { signature ->
            writeFunctionsForSignature(fileWriter, signature)
        }
    }

    private fun writeKtHeader(
        writer: Writer,
        packageName: String,
    ) {
        // Package of kotlin file.
        writer.appendLine("// GENERATED BY divkit/public/json-builder/kotlin/expression-dsl-generator")
        writer.appendLine()
        writer.appendLine("@file:Suppress(\"ktlint\", \"UNUSED_PARAMETER\", \"unused\")")
        writer.appendLine()
        writer.appendLine("package $packageName")
        writer.appendLine()
    }

    private fun writeExtensionFunction(
        writer: Writer,
        signature: FunctionSignature,
    ) {
        require(signature.arguments.size == 1)
        val name = signature.name

        writeSignatureDocumentation(writer, signature, extension = true)
        writer.appendLine()
        val jvmName = StringBuilder().apply {
            append("extension_")
            append(signature.name)
            signature.arguments.forEach { argument ->
                append(argument.type.resolveKotlinBasicType())
            }
        }.toString()
        writer.appendLine("@JvmName(\"$jvmName\")")
        val argumentType = signature.arguments[0].type
        val argumentKotlinType = argumentType.resolveKotlinArgumentType()
        val receiverType = "Expression<$argumentKotlinType>"
        writer.appendLine("fun $receiverType.$name(@Suppress(\"UNUSED_PARAMETER\", \"LocalVariableName\") `do not use`: Unit = Unit) = $name(this)")
        writer.appendLine()
    }

    private fun writeFunctionsForSignature(
        writer: Writer,
        signature: FunctionSignature,
    ) {
        writeSignatureDocumentation(writer, signature)
        writer.appendLine()
        val jvmName = StringBuilder().apply {
            append(signature.name)
            signature.arguments.forEach { argument ->
                append(argument.type.resolveKotlinBasicType())
            }
        }.toString()
        writer.appendLine("@JvmName(\"$jvmName\")")
        writer.appendLine("fun ${signature.name}(")
        signature.arguments.forEachIndexed { index, codegenArgument ->
            val argumentType = codegenArgument.type.resolveKotlinArgumentType()
            if (codegenArgument.isVararg) {
                writer.appendLine("    vararg varargs: Expression<$argumentType>,")
            } else {
                writer.appendLine("    param$index: Expression<$argumentType>,")
            }
        }

        val returnType = signature.returnType.resolveKotlinType()
        writer.appendLine("): Expression<$returnType> =")
        writer.appendLine("    FunctionExpression(")
        writer.appendLine("        \"${signature.name}\",")
        signature.arguments.forEachIndexed { index, codegenArgument ->
            if (codegenArgument.isVararg) {
                writer.appendLine("        *varargs,")
            } else {
                writer.appendLine("        param$index,")
            }
        }
        writer.appendLine("    )")
        writer.appendLine()

        if (signature.supportsExtension()) {
            writeExtensionFunction(writer, signature)
        }
    }

    private fun writeSignatureDocumentation(
        writer: Writer,
        signature: FunctionSignature,
        extension: Boolean = false,
    ) {
        writer.appendLine("/**")
        writer.appendLine(" * ${signature.description.english}")
        writer.appendLine(" *")
        signature.arguments.forEachIndexed { index, argument ->
            if (extension) {
                writer.append(" * @receiver ")
            } else {
                if (argument.isVararg) {
                    writer.append(" * @param varargs ")
                } else {
                    writer.append(" * @param param${index} ")
                }
            }
            writer.append(argument.description.english)
            writer.appendLine()
        }
        writer.appendLine(" * @return function expression")
        writer.appendLine(" */")
    }
}
